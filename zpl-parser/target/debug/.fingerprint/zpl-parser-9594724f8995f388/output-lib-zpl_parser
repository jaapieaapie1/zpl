{"$message_type":"diagnostic","message":"variable `name` is not bound in all patterns","code":{"code":"E0408","explanation":"An \"or\" pattern was used where the variable bindings are not consistently bound\nacross patterns.\n\nErroneous code example:\n\n```compile_fail,E0408\nmatch x {\n    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n                                      //        not bound in pattern #2\n    _ => ()\n}\n```\n\nHere, `y` is bound to the contents of the `Some` and can be used within the\nblock corresponding to the match arm. However, in case `x` is `None`, we have\nnot specified what `y` is, and the block will use a nonexistent variable.\n\nTo fix this error, either split into multiple match arms:\n\n```\nlet x = Some(1);\nmatch x {\n    Some(y) => { /* use y */ }\n    None => { /* ... */ }\n}\n```\n\nor, bind the variable to a field of the same type in all sub-patterns of the\nor pattern:\n\n```\nlet x = (0, 2);\nmatch x {\n    (0, y) | (y, 0) => { /* use y */}\n    _ => {}\n}\n```\n\nIn this example, if `x` matches the pattern `(0, _)`, the second field is set\nto `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\ncases `y` is set to some value.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":2300,"byte_end":2327,"line_start":88,"line_end":88,"column_start":13,"column_end":40,"is_primary":true,"text":[{"text":"            (CommandPrefix::Caret, \"A\") | (CommandPrefix::Caret, name) if name.starts_with(\"A\") => {","highlight_start":13,"highlight_end":40}],"label":"pattern doesn't bind `name`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":2353,"byte_end":2357,"line_start":88,"line_end":88,"column_start":66,"column_end":70,"is_primary":false,"text":[{"text":"            (CommandPrefix::Caret, \"A\") | (CommandPrefix::Caret, name) if name.starts_with(\"A\") => {","highlight_start":66,"highlight_end":70}],"label":"variable not in all patterns","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0408]\u001b[0m\u001b[1m: variable `name` is not bound in all patterns\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:88:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (CommandPrefix::Caret, \"A\") | (CommandPrefix::Caret, name) if name.starts_with(\"A\") => {\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m                          \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mvariable not in all patterns\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91mpattern doesn't bind `name`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":1763,"byte_end":1765,"line_start":71,"line_end":71,"column_start":12,"column_end":14,"is_primary":true,"text":[{"text":"        Ok(())","highlight_start":12,"highlight_end":14}],"label":"expected `Option<Command>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":1760,"byte_end":1762,"line_start":71,"line_end":71,"column_start":9,"column_end":11,"is_primary":false,"text":[{"text":"        Ok(())","highlight_start":9,"highlight_end":11}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `std::option::Option<command::Command>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the type constructed contains `()` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":1763,"byte_end":1765,"line_start":71,"line_end":71,"column_start":12,"column_end":14,"is_primary":false,"text":[{"text":"        Ok(())","highlight_start":12,"highlight_end":14}],"label":"this argument influences the type of `Ok`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":1760,"byte_end":1766,"line_start":71,"line_end":71,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"        Ok(())","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/home/jaapie/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs","byte_start":21353,"byte_end":21355,"line_start":561,"line_end":561,"column_start":5,"column_end":7,"is_primary":true,"text":[{"text":"    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:71:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok(())\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Command>`, found `()`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m:   expected enum `\u001b[1m\u001b[35mstd::option::Option<command::Command>\u001b[0m`\n            found unit type `\u001b[1m\u001b[35m()\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `()` due to the type of the argument passed\n   \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:71:9\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Ok(())\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[96m^^^\u001b[0m\u001b[1m\u001b[94m--\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94mthis argument influences the type of `Ok`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jaapie/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:561:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m561\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `parse_font` found for reference `&parser::Parser<'a>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":2410,"byte_end":2420,"line_start":89,"line_end":89,"column_start":22,"column_end":32,"is_primary":true,"text":[{"text":"                self.parse_font(name, params, span);","highlight_start":22,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `parse` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":395,"byte_end":453,"line_start":21,"line_end":21,"column_start":5,"column_end":63,"is_primary":true,"text":[{"text":"    pub fn parse(mut self) -> Result<Vec<Command>, ParseError> {","highlight_start":5,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `parse_font` found for reference `&parser::Parser<'a>` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:89:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.parse_font(name, params, span);\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `parse` with a similar name, but with different arguments\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:21:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn parse(mut self) -> Result<Vec<Command>, ParseError> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":2387,"byte_end":2455,"line_start":88,"line_end":90,"column_start":100,"column_end":14,"is_primary":true,"text":[{"text":"            (CommandPrefix::Caret, \"A\") | (CommandPrefix::Caret, name) if name.starts_with(\"A\") => {","highlight_start":100,"highlight_end":101},{"text":"                self.parse_font(name, params, span);","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":"expected `Result<Command, ParseError>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `std::result::Result<command::Command, error::ParseError>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:88:100\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               (CommandPrefix::Caret, \"A\") | (CommandPrefix::Caret, name) if name.starts_with(\"A\") => {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________________________________________________________________________________________^\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 self.parse_font(name, params, span);\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Command, ParseError>`, found `()`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m:   expected enum `\u001b[1m\u001b[35mstd::result::Result<command::Command, error::ParseError>\u001b[0m`\n           found unit type `\u001b[1m\u001b[35m()\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 4 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0308, E0408, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0308, E0408, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
